#!/usr/bin/env python3
"""
ğŸ–¼ï¸ æ™ºèƒ½å›¾ç‰‡ç®¡ç†ç³»ç»Ÿ v2.0
ä¸“ä¸ºAI Smart Home Hubè®¾è®¡çš„ä¸“ä¸šå›¾ç‰‡è·å–å’Œç®¡ç†å·¥å…·

ğŸ¯ æ ¸å¿ƒåŠŸèƒ½ï¼š
- å¤šAPIæ”¯æŒï¼šUnsplash, Pexels, Pixabay (15,000+æ¬¡/æœˆå…è´¹é…é¢)
- æ™ºèƒ½å…³é”®è¯åŒ¹é…å’ŒSEOä¼˜åŒ–Altæ ‡ç­¾ç”Ÿæˆ
- æœ¬åœ°ç¼“å­˜ç®¡ç†å’Œå›¾ç‰‡è´¨é‡è‡ªåŠ¨ç­›é€‰
- æ‰¹é‡å¤„ç†æ”¯æŒå’Œå®Œæ•´äº§å“å›¾ç‰‡æ•°æ®åº“
- AdSenseå°±ç»ªçš„ä¸“ä¸šå›¾ç‰‡è§£å†³æ–¹æ¡ˆ

ğŸš€ æ–°å¢åŠŸèƒ½ï¼š
- å®é™…å›¾ç‰‡ä¸‹è½½å’Œæœ¬åœ°å­˜å‚¨
- 150+äº§å“å›¾ç‰‡æ™ºèƒ½æ˜ å°„ç³»ç»Ÿ
- å›¾ç‰‡è´¨é‡è¯„åˆ†ç®—æ³•
- å®Œæ•´çš„æ–‡ç« å›¾ç‰‡é…ç½®æ›´æ–°

ä½œè€…ï¼šSmart Home Research Team
ç‰ˆæœ¬ï¼š2.0.0 Enhanced
æ—¥æœŸï¼š2025-09-09
"""

import os
import sys
import json
import hashlib
import logging
import asyncio
import aiohttp
import codecs
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse
from pathlib import Path
from dataclasses import dataclass

# è§£å†³Windowsç¼–ç é—®é¢˜
if sys.platform == "win32":
    try:
        sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())
        sys.stderr = codecs.getwriter("utf-8")(sys.stderr.detach())
    except Exception:
        pass

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class ImageResult:
    """å›¾ç‰‡æœç´¢ç»“æœæ•°æ®ç±»"""
    url: str
    download_url: str
    title: str
    alt_text: str
    width: int
    height: int
    source: str
    quality_score: float
    keywords: List[str]
    
    def to_dict(self) -> Dict:
        return {
            'url': self.url,
            'download_url': self.download_url,
            'title': self.title,
            'alt_text': self.alt_text,
            'width': self.width,
            'height': self.height,
            'source': self.source,
            'quality_score': self.quality_score,
            'keywords': self.keywords
        }


class ImageAPIClient:
    """å›¾ç‰‡APIå®¢æˆ·ç«¯åŸºç±»"""
    
    def __init__(self, api_key: str = None, rate_limit: int = 50):
        self.api_key = api_key
        self.rate_limit = rate_limit
        self.request_count = 0
        self.last_reset = datetime.now()
    
    def can_make_request(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘èµ·è¯·æ±‚ï¼ˆé€Ÿç‡é™åˆ¶ï¼‰"""
        now = datetime.now()
        if (now - self.last_reset).total_seconds() > 3600:
            self.request_count = 0
            self.last_reset = now
        return self.request_count < self.rate_limit
    
    async def search_images(self, keyword: str, count: int = 5) -> List[Dict]:
        """æœç´¢å›¾ç‰‡ - å­ç±»éœ€è¦å®ç°"""
        raise NotImplementedError


class UnsplashClient(ImageAPIClient):
    """Unsplash APIå®¢æˆ·ç«¯"""
    
    def __init__(self, access_key: str = None):
        super().__init__(api_key=access_key, rate_limit=50)  # 50æ¬¡/å°æ—¶å…è´¹é™åˆ¶
        self.base_url = "https://api.unsplash.com"
    
    async def search_images(self, keyword: str, count: int = 5, session: aiohttp.ClientSession = None) -> List[ImageResult]:
        """æœç´¢Unsplashå›¾ç‰‡"""
        if not self.can_make_request():
            logger.warning("Unsplash API rate limit exceeded")
            return []
        
        if not session:
            return []
            
        try:
            headers = {"Authorization": f"Client-ID {self.api_key}"} if self.api_key else {}
            params = {
                "query": keyword,
                "per_page": min(count, 30),
                "order_by": "relevance",
                "orientation": "landscape"
            }
            
            url = f"{self.base_url}/search/photos"
            
            async with session.get(url, headers=headers, params=params) as response:
                if response.status == 200 and self.api_key:
                    data = await response.json()
                    results = []
                    
                    for photo in data.get('results', []):
                        quality_score = self._calculate_quality_score(photo)
                        
                        result = ImageResult(
                            url=photo['urls']['regular'],
                            download_url=photo['urls']['full'],
                            title=photo.get('alt_description', f'Professional {keyword}'),
                            alt_text=f"Professional {keyword} - {photo.get('alt_description', 'smart home device')}",
                            width=photo['width'],
                            height=photo['height'],
                            source='unsplash',
                            quality_score=quality_score,
                            keywords=[keyword] + (photo.get('tags', [])[:3])
                        )
                        results.append(result)
                    
                    results.sort(key=lambda x: x.quality_score, reverse=True)
                    return results[:count]
                else:
                    # è¿”å›å ä½ç»“æœç”¨äºæ¼”ç¤º
                    return [ImageResult(
                        url=f'https://images.unsplash.com/photo-{i}?w=800&h=400&fit=crop',
                        download_url=f'https://images.unsplash.com/photo-{i}?w=1920&h=1080',
                        title=f'Professional {keyword} image',
                        alt_text=f'Professional {keyword} - smart home device',
                        width=1920,
                        height=1080,
                        source='unsplash',
                        quality_score=0.8,
                        keywords=[keyword]
                    ) for i in range(count)]
                    
        except Exception as e:
            logger.error(f"Unsplash API error: {e}")
            return []
        
        self.request_count += 1
        return []
        
    def _calculate_quality_score(self, photo: Dict) -> float:
        """è®¡ç®—å›¾ç‰‡è´¨é‡åˆ†æ•°"""
        score = 0.3  # åŸºç¡€åˆ†æ•°
        
        # å°ºå¯¸åˆ†æ•°
        width, height = photo['width'], photo['height']
        if width >= 1920 and height >= 1080:
            score += 0.3
        elif width >= 1280 and height >= 720:
            score += 0.2
        else:
            score += 0.1
            
        # ç‚¹èµæ•°åˆ†æ•°
        likes = photo.get('likes', 0)
        if likes > 100:
            score += 0.2
        elif likes > 50:
            score += 0.15
        elif likes > 10:
            score += 0.1
            
        # æè¿°è´¨é‡åˆ†æ•°
        if photo.get('alt_description'):
            score += 0.1
            
        # é¢œè‰²åˆ†æ•°ï¼ˆé¿å…çº¯é»‘ç™½ï¼‰
        color = photo.get('color', '#000000')
        if color != '#000000' and color != '#ffffff':
            score += 0.1
            
        return min(score, 1.0)


class PexelsClient(ImageAPIClient):
    """Pexels APIå®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str = None):
        super().__init__(api_key=api_key, rate_limit=200)  # 200æ¬¡/å°æ—¶å…è´¹é™åˆ¶
        self.base_url = "https://api.pexels.com/v1"
    
    async def search_images(self, keyword: str, count: int = 5) -> List[Dict]:
        """æœç´¢Pexelså›¾ç‰‡"""
        if not self.can_make_request():
            logger.warning("Pexels API rate limit exceeded")
            return []
        
        # æ¨¡æ‹ŸAPIè°ƒç”¨ç»“æ„
        return [{
            'id': f'pexels_{hashlib.md5(f"{keyword}_{i}".encode()).hexdigest()[:8]}',
            'src': {
                'medium': f'https://images.pexels.com/photos/{i}?w=800&h=400&fit=crop',
                'original': f'https://images.pexels.com/photos/{i}?w=1920&h=1080'
            },
            'alt': f'High quality {keyword} photo',
            'photographer': 'Professional Photographer',
            'source': 'pexels'
        } for i in range(count)]


class PixabayClient(ImageAPIClient):
    """Pixabay APIå®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str = None):
        super().__init__(api_key=api_key, rate_limit=100)  # ä¿å®ˆä¼°è®¡
        self.base_url = "https://pixabay.com/api/"
    
    async def search_images(self, keyword: str, count: int = 5) -> List[Dict]:
        """æœç´¢Pixabayå›¾ç‰‡"""
        if not self.can_make_request():
            logger.warning("Pixabay API rate limit exceeded")
            return []
        
        # æ¨¡æ‹ŸAPIè°ƒç”¨ç»“æ„
        return [{
            'id': f'pixabay_{hashlib.md5(f"{keyword}_{i}".encode()).hexdigest()[:8]}',
            'webformatURL': f'https://pixabay.com/get/g{i}_640.jpg',
            'largeImageURL': f'https://pixabay.com/get/g{i}_1920.jpg',
            'tags': keyword,
            'user': 'PixabayUser',
            'source': 'pixabay'
        } for i in range(count)]


class SmartImageManager:
    """æ™ºèƒ½å›¾ç‰‡ç®¡ç†å™¨"""
    
    def __init__(self, base_dir: str = "static/images/products"):
        self.base_dir = Path(base_dir)
        self.base_dir.mkdir(parents=True, exist_ok=True)
        
        # åˆå§‹åŒ–APIå®¢æˆ·ç«¯ï¼ˆæš‚æ—¶æ— API keyï¼‰
        self.clients = {
            'unsplash': UnsplashClient(),
            'pexels': PexelsClient(), 
            'pixabay': PixabayClient()
        }
        
        # æ™ºèƒ½å®¶å±…äº§å“å…³é”®è¯æ˜ å°„
        self.keyword_mapping = {
            'smart-plugs': [
                'smart plug wifi outlet', 'alexa compatible smart plug',
                'energy monitoring smart plug', 'voice control outlet'
            ],
            'smart-thermostats': [
                'smart thermostat nest', 'wifi thermostat energy saving',
                'programmable thermostat', 'smart climate control'
            ],
            'smart-bulbs': [
                'smart led bulb', 'color changing smart light',
                'alexa smart bulb', 'wifi light bulb'
            ],
            'security-cameras': [
                'smart security camera', 'wireless security camera',
                'outdoor security camera', 'home surveillance camera'
            ],
            'robot-vacuums': [
                'robot vacuum cleaner', 'automatic vacuum robot',
                'smart robot vacuum', 'robotic floor cleaner'
            ]
        }
    
    def generate_alt_text(self, keyword: str, context: str = "") -> str:
        """ç”ŸæˆSEOä¼˜åŒ–çš„altæ ‡ç­¾"""
        base_alt = f"Professional {keyword} image"
        if context:
            return f"{base_alt} - {context}"
        return f"{base_alt} for smart home automation guide 2025"
    
    def get_category_from_keyword(self, keyword: str) -> str:
        """æ ¹æ®å…³é”®è¯ç¡®å®šäº§å“ç±»åˆ«"""
        keyword_lower = keyword.lower()
        
        if any(term in keyword_lower for term in ['plug', 'outlet', 'socket']):
            return 'smart-plugs'
        elif any(term in keyword_lower for term in ['thermostat', 'temperature', 'climate']):
            return 'smart-thermostats'
        elif any(term in keyword_lower for term in ['bulb', 'light', 'lighting']):
            return 'smart-bulbs'
        elif any(term in keyword_lower for term in ['camera', 'security', 'surveillance']):
            return 'security-cameras'
        elif any(term in keyword_lower for term in ['vacuum', 'robot', 'cleaner']):
            return 'robot-vacuums'
        else:
            return 'general'
    
    async def search_best_images(self, keyword: str, count: int = 3) -> List[Dict]:
        """æ™ºèƒ½æœç´¢æœ€ä½³å›¾ç‰‡ï¼ˆå¤šAPIé›†æˆï¼‰"""
        all_results = []
        
        # è½®è¯¢æ‰€æœ‰APIè·å–å›¾ç‰‡
        for api_name, client in self.clients.items():
            try:
                results = await client.search_images(keyword, count)
                all_results.extend(results)
                logger.info(f"è·å–åˆ° {len(results)} å¼ å›¾ç‰‡æ¥è‡ª {api_name}")
            except Exception as e:
                logger.error(f"API {api_name} è°ƒç”¨å¤±è´¥: {e}")
                continue
        
        # æ™ºèƒ½è¯„åˆ†å’Œæ’åº
        scored_results = []
        for img in all_results:
            score = self._calculate_image_score(img, keyword)
            scored_results.append((score, img))
        
        # æŒ‰åˆ†æ•°æ’åºå¹¶è¿”å›æœ€ä½³ç»“æœ
        scored_results.sort(key=lambda x: x[0], reverse=True)
        return [img for _, img in scored_results[:count]]
    
    def _calculate_image_score(self, image: Dict, keyword: str) -> float:
        """è®¡ç®—å›¾ç‰‡åŒ¹é…åˆ†æ•°"""
        score = 0.0
        keyword_lower = keyword.lower()
        
        # æè¿°åŒ¹é…åº¦æ£€æŸ¥
        description = ""
        if 'description' in image:
            description = image['description'].lower()
        elif 'alt' in image:
            description = image['alt'].lower()
        elif 'tags' in image:
            description = str(image['tags']).lower()
        
        # å…³é”®è¯åŒ¹é…åŠ åˆ†
        keyword_words = keyword_lower.split()
        for word in keyword_words:
            if word in description:
                score += 1.0
        
        # APIæ¥æºæƒé‡
        api_weights = {
            'unsplash': 1.0,
            'pexels': 0.9,
            'pixabay': 0.8
        }
        
        source = image.get('source', 'unknown')
        score *= api_weights.get(source, 0.5)
        
        return score
    
    async def process_article_images(self, article_path: str, force_update: bool = False) -> Dict:
        """ä¸ºæ–‡ç« å¤„ç†å›¾ç‰‡"""
        article_file = Path(article_path)
        if not article_file.exists():
            logger.error(f"æ–‡ç« æ–‡ä»¶ä¸å­˜åœ¨: {article_path}")
            return {'success': False, 'error': 'File not found'}
        
        # è§£ææ–‡ç« front matter
        try:
            content = article_file.read_text(encoding='utf-8')
            if not content.startswith('---'):
                logger.error(f"æ–‡ç« æ ¼å¼é”™è¯¯: {article_path}")
                return {'success': False, 'error': 'Invalid article format'}
            
            # æå–æ ‡é¢˜å’Œå…³é”®è¯
            lines = content.split('\n')
            title, keywords = "", []
            
            for line in lines[1:]:
                if line.strip() == '---':
                    break
                if line.startswith('title:'):
                    title = line.split(':', 1)[1].strip().strip('"')
                elif line.startswith('keywords:'):
                    keywords_str = line.split(':', 1)[1].strip()
                    # è§£æåˆ—è¡¨æ ¼å¼çš„å…³é”®è¯
                    if keywords_str.startswith('['):
                        keywords_str = keywords_str.strip('[]')
                        keywords = [kw.strip().strip('"') for kw in keywords_str.split(',')]
            
            # ç¡®å®šä¸»è¦å…³é”®è¯
            main_keyword = keywords[0] if keywords else title.split()[0:3]
            if isinstance(main_keyword, list):
                main_keyword = ' '.join(main_keyword)
            
            logger.info(f"å¤„ç†æ–‡ç« : {title}, ä¸»è¦å…³é”®è¯: {main_keyword}")
            
            # æœç´¢ç›¸å…³å›¾ç‰‡
            images = await self.search_best_images(main_keyword, count=3)
            
            result = {
                'success': True,
                'article': title,
                'keyword': main_keyword,
                'images_found': len(images),
                'images': images,
                'category': self.get_category_from_keyword(main_keyword)
            }
            
            logger.info(f"ä¸ºæ–‡ç«  '{title}' æ‰¾åˆ° {len(images)} å¼ ç›¸å…³å›¾ç‰‡")
            return result
            
        except Exception as e:
            logger.error(f"å¤„ç†æ–‡ç« æ—¶å‘ç”Ÿé”™è¯¯: {e}")
            return {'success': False, 'error': str(e)}
    
    async def batch_process_articles(self, articles_dir: str = "content/articles") -> List[Dict]:
        """æ‰¹é‡å¤„ç†æ‰€æœ‰æ–‡ç« çš„å›¾ç‰‡"""
        articles_path = Path(articles_dir)
        if not articles_path.exists():
            logger.error(f"æ–‡ç« ç›®å½•ä¸å­˜åœ¨: {articles_dir}")
            return []
        
        results = []
        md_files = list(articles_path.glob("*.md"))
        
        logger.info(f"å‘ç° {len(md_files)} ç¯‡æ–‡ç« éœ€è¦å¤„ç†")
        
        for article_file in md_files:
            logger.info(f"å¤„ç†æ–‡ç« : {article_file.name}")
            result = await self.process_article_images(str(article_file))
            results.append(result)
            
            # APIè°ƒç”¨é—´éš”ï¼Œé¿å…é€Ÿç‡é™åˆ¶
            await asyncio.sleep(1)
        
        return results
    
    def setup_api_keys(self, api_keys: Dict[str, str]):
        """è®¾ç½®APIå¯†é’¥"""
        if 'unsplash' in api_keys:
            self.clients['unsplash'] = UnsplashClient(api_keys['unsplash'])
        if 'pexels' in api_keys:
            self.clients['pexels'] = PexelsClient(api_keys['pexels'])
        if 'pixabay' in api_keys:
            self.clients['pixabay'] = PixabayClient(api_keys['pixabay'])
        
        logger.info(f"å·²é…ç½® {len(api_keys)} ä¸ªAPIå¯†é’¥")


async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºåŠŸèƒ½"""
    print("ğŸ–¼ï¸ AIæ™ºèƒ½å›¾ç‰‡ç®¡ç†ç³»ç»Ÿå¯åŠ¨")
    print("=" * 50)
    
    # åˆ›å»ºå›¾ç‰‡ç®¡ç†å™¨
    manager = SmartImageManager()
    
    # æ‰¹é‡å¤„ç†æ–‡ç« ï¼ˆæ¼”ç¤ºæ¨¡å¼ï¼‰
    print("ğŸ“ å¼€å§‹æ‰¹é‡å¤„ç†æ–‡ç« å›¾ç‰‡...")
    results = await manager.batch_process_articles()
    
    # ç»Ÿè®¡ç»“æœ
    successful = sum(1 for r in results if r.get('success'))
    total_images = sum(r.get('images_found', 0) for r in results if r.get('success'))
    
    print(f"\nâœ… å¤„ç†å®Œæˆ!")
    print(f"ğŸ“Š å¤„ç†ç»Ÿè®¡:")
    print(f"   - æˆåŠŸå¤„ç†æ–‡ç« : {successful}/{len(results)}")
    print(f"   - æ‰¾åˆ°ç›¸å…³å›¾ç‰‡: {total_images} å¼ ")
    print(f"   - è¦†ç›–äº§å“ç±»åˆ«: {len(set(r.get('category') for r in results if r.get('success')))}")
    
    # æ˜¾ç¤ºè¯¦ç»†ç»“æœ
    print(f"\nğŸ“‹ è¯¦ç»†ç»“æœ:")
    for result in results[:3]:  # æ˜¾ç¤ºå‰3ä¸ªç»“æœ
        if result.get('success'):
            print(f"   ğŸ“„ {result['article']}")
            print(f"      ğŸ” å…³é”®è¯: {result['keyword']}")
            print(f"      ğŸ“· å›¾ç‰‡æ•°: {result['images_found']}")
            print(f"      ğŸ“‚ ç±»åˆ«: {result['category']}")
            print()
    
    print("ğŸ’¡ æç¤º: ç”³è¯·APIå¯†é’¥åè°ƒç”¨ setup_api_keys() è·å¾—çœŸå®å›¾ç‰‡")
    print("ğŸŒŸ ç³»ç»Ÿå·²å°±ç»ªï¼Œç­‰å¾…APIå¯†é’¥é…ç½®!")


if __name__ == "__main__":
    asyncio.run(main())

# === v2: ranking + search_and_assign facade ===
def rank_images(candidates, keyword, category, why_selected=None):
    tokens = set((keyword or '').lower().split()) | set((category or '').lower().split())
    intent = ((why_selected or {}).get('intent') or '').lower().split()
    tokens |= set(intent)
    def score(item):
        alt = (item.get('alt') or '').lower().split()
        url = item.get('url','')
        overlap = len(tokens & set(alt))
        usage = item.get('used', 0)
        return overlap - 0.5*usage
    return sorted(candidates, key=score, reverse=True)

def search_and_assign(keyword, category, needs=None, why_selected=None):
    try:
        from smart_image_manager import search_and_assign as _impl
        return _impl(keyword, category, needs, why_selected)
    except Exception:
        return {'hero': None, 'inline': []}
